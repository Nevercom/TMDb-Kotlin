{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TMDb-Kotlin \u00b6 This is the TMDb API documentation page for the TMDb wrapper TMDb-Kotlin written in and for Kotlin. I\u2019ve created the library for Android apps primarily, but it can be also used in any Gradle project. Most of the functionality and callbacks are implemented (except some account related calls). The library is therefore WIP, so there might be breaking changes in the future (but I doubt it). The library is built on top of Retrofit2 for networking. If you\u2019ve got questions, suggestions or encounter any issues feel free to contact me via GitHub issues . I\u2019d be happy to help ;) Used libraries and thanks \u00b6 Retrofit2 by Square Moshi by Square NetworkResponseAdapter by Kshitij Chauhan ThreeTenABP by Jake Wharton Thanks go to The Movie Database for the API Uwe Trottmann\u2019s tmdb-java for the basic idea and some structuring elements Kshitij Chauhan\u2019 NetworkResponseAdapter for the great error handling Attribution Requirements \u00b6 This wrapper is for the The Movie Database API. Using the data requires to attribute the data source. Same applies to JustWatch data if you're using their data. For more info read here: Link","title":"Introduction"},{"location":"#tmdb-kotlin","text":"This is the TMDb API documentation page for the TMDb wrapper TMDb-Kotlin written in and for Kotlin. I\u2019ve created the library for Android apps primarily, but it can be also used in any Gradle project. Most of the functionality and callbacks are implemented (except some account related calls). The library is therefore WIP, so there might be breaking changes in the future (but I doubt it). The library is built on top of Retrofit2 for networking. If you\u2019ve got questions, suggestions or encounter any issues feel free to contact me via GitHub issues . I\u2019d be happy to help ;)","title":"TMDb-Kotlin"},{"location":"#used-libraries-and-thanks","text":"Retrofit2 by Square Moshi by Square NetworkResponseAdapter by Kshitij Chauhan ThreeTenABP by Jake Wharton Thanks go to The Movie Database for the API Uwe Trottmann\u2019s tmdb-java for the basic idea and some structuring elements Kshitij Chauhan\u2019 NetworkResponseAdapter for the great error handling","title":"Used libraries and thanks"},{"location":"#attribution-requirements","text":"This wrapper is for the The Movie Database API. Using the data requires to attribute the data source. Same applies to JustWatch data if you're using their data. For more info read here: Link","title":"Attribution Requirements"},{"location":"future-plans/","text":"Plans \u00b6 Ideas \u00b6 Support more Retrofit2 types, e.g Call<T> , RxJava ( Single + Completable ) by using artifacts","title":"Future plans"},{"location":"future-plans/#plans","text":"","title":"Plans"},{"location":"future-plans/#ideas","text":"Support more Retrofit2 types, e.g Call<T> , RxJava ( Single + Completable ) by using artifacts","title":"Ideas"},{"location":"services/","text":"Services \u00b6 Currently, all essential endpoints are usable. In the following you\u2019ll find the necesary links for the supported services. Brief examples to calls can be found on the given test links or on the Recipes page. Services and endpoints not going to be implemented (niche) Reviews Changes TV Shows: Screened theatrically Credit: Details by credit id Person: Tagged images List: Update items (only comment as addition) Check item status Account: Recommended shows/movies (part of v4, but v3 is used for account) Data which is static : Configuration such as available languages/regions/jobs and image resolutions Available watch providers \u2192 All implemented services (GitHub) \u2192 Official documentation (The Movie Database) \u2192 Unit tests / proof examples (GitHub)","title":"Services"},{"location":"services/#services","text":"Currently, all essential endpoints are usable. In the following you\u2019ll find the necesary links for the supported services. Brief examples to calls can be found on the given test links or on the Recipes page. Services and endpoints not going to be implemented (niche) Reviews Changes TV Shows: Screened theatrically Credit: Details by credit id Person: Tagged images List: Update items (only comment as addition) Check item status Account: Recommended shows/movies (part of v4, but v3 is used for account) Data which is static : Configuration such as available languages/regions/jobs and image resolutions Available watch providers \u2192 All implemented services (GitHub) \u2192 Official documentation (The Movie Database) \u2192 Unit tests / proof examples (GitHub)","title":"Services"},{"location":"design/classes/","text":"Recurrent classes & concepts \u00b6 Slim variants \u00b6 Slims are classes with fewer data in comparison to its normal variant. They\u2019re used in search results (= lists), so TmdbMovie.Slim doesn\u2019t contain data such as production countries and companies for example. TmdbPage<Type> \u00b6 This class represents a page of items for the given type, for example TmdbPage<TmdbMovie.Slim> . Pages are used primarily in searches or e.g. movie/tv show recommendations where you can specify the actual page. \u2192 Doc TmdbImage \u00b6 TmdbImage is used for all image paths including poster, backdrop and still paths. If the images are standalone - for example a poster or backdrop as part of a movie - they don\u2019t contain additional data like width and height . These are available for concrete calls only like <Service>.posters(id) or if AppendToResponse.Item.IMAGE is used. The class supports the method get(Quality) which produces the full link to the image resource. \u2192 Doc TmdbDate \u00b6 TmdbDate is a wrapper class for LocalDate which supports the method localize(Locale, Format) to return a date string according to the user\u2019s location. \u2192 Doc TmdbError \u00b6 If there is an server error during networking this class is returned (requires check for NetworkResponse.ServerError ). In most scenarios TmdbError.DefaultError is returned which is caused by not-found resources often. TmdbError.PostError will be returned if malformed data is passed to the body. \u2192 Doc TmdbMessage \u00b6 This class is used for calls which return status data and simple data like access token and account related messages (id, successfull update data etc.). It contains sub-classes which provide the essential data. \u2192 Doc TmdbBody \u00b6 TmdbBody \u2018s inner classes are used to pass data for updating account related data in AccountService , for example adding items to a list or update its description (set valid session id required). \u2192 Doc AppendToResponse \u00b6 Some classes support optional addable data like videos or images which can be retrieved directly in the details call. Classes supporting the functionality: TmdbShow , TmdbSeason , TmdbEpisode , TmdbMovie , TmdbPerson For more info how it works you should look on the official TMDb page and in Recipes for examples. \u2192 Doc Enumerations \u00b6 All available enumerations are listed here: Github","title":"Recurrent classes & concepts"},{"location":"design/classes/#recurrent-classes-concepts","text":"","title":"Recurrent classes &amp; concepts"},{"location":"design/classes/#slim-variants","text":"Slims are classes with fewer data in comparison to its normal variant. They\u2019re used in search results (= lists), so TmdbMovie.Slim doesn\u2019t contain data such as production countries and companies for example.","title":"Slim variants"},{"location":"design/classes/#tmdbpagetype","text":"This class represents a page of items for the given type, for example TmdbPage<TmdbMovie.Slim> . Pages are used primarily in searches or e.g. movie/tv show recommendations where you can specify the actual page. \u2192 Doc","title":"TmdbPage&lt;Type&gt;"},{"location":"design/classes/#tmdbimage","text":"TmdbImage is used for all image paths including poster, backdrop and still paths. If the images are standalone - for example a poster or backdrop as part of a movie - they don\u2019t contain additional data like width and height . These are available for concrete calls only like <Service>.posters(id) or if AppendToResponse.Item.IMAGE is used. The class supports the method get(Quality) which produces the full link to the image resource. \u2192 Doc","title":"TmdbImage"},{"location":"design/classes/#tmdbdate","text":"TmdbDate is a wrapper class for LocalDate which supports the method localize(Locale, Format) to return a date string according to the user\u2019s location. \u2192 Doc","title":"TmdbDate"},{"location":"design/classes/#tmdberror","text":"If there is an server error during networking this class is returned (requires check for NetworkResponse.ServerError ). In most scenarios TmdbError.DefaultError is returned which is caused by not-found resources often. TmdbError.PostError will be returned if malformed data is passed to the body. \u2192 Doc","title":"TmdbError"},{"location":"design/classes/#tmdbmessage","text":"This class is used for calls which return status data and simple data like access token and account related messages (id, successfull update data etc.). It contains sub-classes which provide the essential data. \u2192 Doc","title":"TmdbMessage"},{"location":"design/classes/#tmdbbody","text":"TmdbBody \u2018s inner classes are used to pass data for updating account related data in AccountService , for example adding items to a list or update its description (set valid session id required). \u2192 Doc","title":"TmdbBody"},{"location":"design/classes/#appendtoresponse","text":"Some classes support optional addable data like videos or images which can be retrieved directly in the details call. Classes supporting the functionality: TmdbShow , TmdbSeason , TmdbEpisode , TmdbMovie , TmdbPerson For more info how it works you should look on the official TMDb page and in Recipes for examples. \u2192 Doc","title":"AppendToResponse"},{"location":"design/classes/#enumerations","text":"All available enumerations are listed here: Github","title":"Enumerations"},{"location":"design/overview/","text":"Design \u00b6 I\u2019m a friend of well-structured / conclusive code and intuitive usage. So I tried to design the library in such way by JSON deserialization into objects instead of Strings for more out-of-the-box functionalities, combining similar JSON structures and reduce nested objects as much as possible to lighten the library and ensuring intuitive and natural workflow by - for example - returning lists directly. Naming conventions \u00b6 Some data retrieved from the API isn\u2019t immediately apparent in my opinion - for example iso_639_1 but you won\u2019t probably think of it as the language tag on your first spot. So I named such data fields into more human language and also some query parameters: TMDb field / query parameter Named in this library Example iso_639_1 languageCode de (German) iso_3166_1 countryCode DE (Germany) language language de or de-DE (German / Germany) region languageCode de (German) Response restructuring \u00b6 Some API endpoints return data which is related to the language/country code (for example movie release dates). Instead of returning a new object class the call returns a Map<String, List<T> for example where the key is language / country code.","title":"Overview"},{"location":"design/overview/#design","text":"I\u2019m a friend of well-structured / conclusive code and intuitive usage. So I tried to design the library in such way by JSON deserialization into objects instead of Strings for more out-of-the-box functionalities, combining similar JSON structures and reduce nested objects as much as possible to lighten the library and ensuring intuitive and natural workflow by - for example - returning lists directly.","title":"Design"},{"location":"design/overview/#naming-conventions","text":"Some data retrieved from the API isn\u2019t immediately apparent in my opinion - for example iso_639_1 but you won\u2019t probably think of it as the language tag on your first spot. So I named such data fields into more human language and also some query parameters: TMDb field / query parameter Named in this library Example iso_639_1 languageCode de (German) iso_3166_1 countryCode DE (Germany) language language de or de-DE (German / Germany) region languageCode de (German)","title":"Naming conventions"},{"location":"design/overview/#response-restructuring","text":"Some API endpoints return data which is related to the language/country code (for example movie release dates). Instead of returning a new object class the call returns a Map<String, List<T> for example where the key is language / country code.","title":"Response restructuring"},{"location":"quick_start/making_requests/","text":"Making requests \u00b6 At the moment all calls are suspended and require to be called in Kotlin Coroutines. An overview of how to use them can be found here: Composing suspending functions . They\u2019re also wrapped in NetworkResponse s, so you can react for errors easily or access the data directly. Examples \u00b6 Searching with error handling \u00b6 There are four cases which the response can take value of: Success , ServerError , NetworkError and UnknownError . For more info you should take a look here . fun main () = runBlocking { TMDb . init ( \"YOUR_API_KEY\" ) when ( val response = TMDb . searchService . tv ( \"Black Clover\" )) { // Type: NetworkResponse<TmdbPage<TmdbShow.Slim>, TmdbError.DefaultError> is NetworkResponse . Success -> { val searchPage : TmdbPage < TmdbShow . Slim > = response . body if ( searchPage . totalResults > 0 ) { println ( \"First result's title: ${searchPage.results[0].title}\" ) } } is NetworkResponse . ServerError -> { val errorBody : TmdbErrorResponse = response . body println ( \"ServerError: Message = ${errorBody?.message}\" ) } is NetworkResponse . NetworkError -> { val error : IOException = response . error println ( \"NetworkError: Message = ${error.message}\" ) } is NetworkResponse . UnknownError -> { val error : Throwable = response . error println ( \"UnknownError: Message = ${error.message}\" ) } } } Searching with direct access \u00b6 You can also access the response directly without checking for the NetworkResponse type by calling invoke() . In this case the object might be null : fun main () = runBlocking { TMDb . init ( \"YOUR_API_KEY\" ) val searchPage : TmdbPage < TmdbShow . Slim >? = TMDb . searchService . tv ( \"Black Clover\" ). invoke () searchPage ?. let { if ( searchPage . totalResults > 0 ) { println ( \"First result: ${searchPage.results[0].title}\" ) } } }","title":"Making requests"},{"location":"quick_start/making_requests/#making-requests","text":"At the moment all calls are suspended and require to be called in Kotlin Coroutines. An overview of how to use them can be found here: Composing suspending functions . They\u2019re also wrapped in NetworkResponse s, so you can react for errors easily or access the data directly.","title":"Making requests"},{"location":"quick_start/making_requests/#examples","text":"","title":"Examples"},{"location":"quick_start/making_requests/#searching-with-error-handling","text":"There are four cases which the response can take value of: Success , ServerError , NetworkError and UnknownError . For more info you should take a look here . fun main () = runBlocking { TMDb . init ( \"YOUR_API_KEY\" ) when ( val response = TMDb . searchService . tv ( \"Black Clover\" )) { // Type: NetworkResponse<TmdbPage<TmdbShow.Slim>, TmdbError.DefaultError> is NetworkResponse . Success -> { val searchPage : TmdbPage < TmdbShow . Slim > = response . body if ( searchPage . totalResults > 0 ) { println ( \"First result's title: ${searchPage.results[0].title}\" ) } } is NetworkResponse . ServerError -> { val errorBody : TmdbErrorResponse = response . body println ( \"ServerError: Message = ${errorBody?.message}\" ) } is NetworkResponse . NetworkError -> { val error : IOException = response . error println ( \"NetworkError: Message = ${error.message}\" ) } is NetworkResponse . UnknownError -> { val error : Throwable = response . error println ( \"UnknownError: Message = ${error.message}\" ) } } }","title":"Searching with error handling"},{"location":"quick_start/making_requests/#searching-with-direct-access","text":"You can also access the response directly without checking for the NetworkResponse type by calling invoke() . In this case the object might be null : fun main () = runBlocking { TMDb . init ( \"YOUR_API_KEY\" ) val searchPage : TmdbPage < TmdbShow . Slim >? = TMDb . searchService . tv ( \"Black Clover\" ). invoke () searchPage ?. let { if ( searchPage . totalResults > 0 ) { println ( \"First result: ${searchPage.results[0].title}\" ) } } }","title":"Searching with direct access"},{"location":"quick_start/setup/","text":"Setup \u00b6 Import into your project \u00b6 This library uses JitPack.io so you\u2019ve to add the repo to your projects gradle file: repositories { maven { url \"https://jitpack.io\" } } Then, on app level add the library: dependencies { // Commit hash from 2021-04-24 implementation \"com.github.vkay94:TMDb-Kotlin:89c46a06d14e5de4577510e5493008a148bd5687\" // This module uses the ThreetenABP library to ensure LocalDate support in // Android versions below API 26 so you should use this as well for // using dates. implementation \"com.jakewharton.threetenabp:threetenabp:1.3.0\" } Initialize the instance \u00b6 Basic initialization: TMDb . init ( API_KEY [, V4_AUTH_KEY ]) // [] = optional In Android applications it is best-practice to initialize the instance directly within App to make use of Kotlin\u2019s objects, so the instance can be used in the whole app directly. App.kt class App : Application () { override fun onCreate () { TMDb . init ( API_KEY ) // or TMDb.init(YOUR_API_KEY, V4_AUTH_KEY) for authentication } } AndroidManifest.xml <manifest ... > <uses-permission android:name= \"android.permission.INTERNET\" /> <application android:name= \".App\" ... > </application> </manifest>","title":"Setup"},{"location":"quick_start/setup/#setup","text":"","title":"Setup"},{"location":"quick_start/setup/#import-into-your-project","text":"This library uses JitPack.io so you\u2019ve to add the repo to your projects gradle file: repositories { maven { url \"https://jitpack.io\" } } Then, on app level add the library: dependencies { // Commit hash from 2021-04-24 implementation \"com.github.vkay94:TMDb-Kotlin:89c46a06d14e5de4577510e5493008a148bd5687\" // This module uses the ThreetenABP library to ensure LocalDate support in // Android versions below API 26 so you should use this as well for // using dates. implementation \"com.jakewharton.threetenabp:threetenabp:1.3.0\" }","title":"Import into your project"},{"location":"quick_start/setup/#initialize-the-instance","text":"Basic initialization: TMDb . init ( API_KEY [, V4_AUTH_KEY ]) // [] = optional In Android applications it is best-practice to initialize the instance directly within App to make use of Kotlin\u2019s objects, so the instance can be used in the whole app directly. App.kt class App : Application () { override fun onCreate () { TMDb . init ( API_KEY ) // or TMDb.init(YOUR_API_KEY, V4_AUTH_KEY) for authentication } } AndroidManifest.xml <manifest ... > <uses-permission android:name= \"android.permission.INTERNET\" /> <application android:name= \".App\" ... > </application> </manifest>","title":"Initialize the instance"},{"location":"recipes/","text":"Recipes \u00b6 In this section I\u2019ll show you some examples and customizations which can be done with this library. Customization \u00b6 Caching \u00b6 Since the API data isn\u2019t updating that often it isn\u2019t necessary to fetch the same resource over and over. You can set the cache time interval and the condition for being connected to the network: // Setting condition or passing null to disable caching (default: null) TMDb . onlineCondition { return InternetUtility . isConnectedToNetwork () } // Duration to use cached data if connected to network (default: 2 hours) TMDb . onlineCache ( /* duration */ 2 , /* unit */ TimeUnit . HOURS ) // Duration to use cached data if disconnected from network (default: 2 days) TMDb . offlineCache ( /* duration */ 1 , /* unit */ TimeUnit . DAYS ) Modify requests before calling \u00b6 By default, requests support caching, but you can add your own modifications by using TMDbInterceptor if you\u2019d like: val customInterceptor = TMDbInterceptor ( \"YOUR_KEY\" , \"\" ) { requestBuilder -> requestBuilder . addHeader ( \"headerName\" , \"value\" ) // or a custom offline handling } TMDb . tmdbInterceptor = customInterceptor TMDb . init ( \"YOUR_KEY\" ) General \u00b6 AppendToResponse \u00b6 With AppendToReponse you can add optional data to the details call such as images and credits. If it isn\u2019t passed accessing the field returns an empty list (or of the API doesn\u2019t have the data). val appendToResponse = AppendToResponse ( AppendToResponse . Item . VIDEOS ) val tvShow : TmdbShow = TMDb . showService . details ( SOME_ID , append = appendToResponse ). invoke () !! val youtubeVideoThumbnail : String ? = if ( tvShow . videos . isEmpty ()) null else tvShow . videos [ 0 ]. youtubeThumbnail () Get targeted data directly \u00b6 If you\u2019re interested in specific data only (for example movies/shows in which a person was cast member of), you can retrieve this data directly with a call: val castMovies : List < TmdbMovie . Slim > = TMDb . personService . movieCast ( SOME_ID ). invoke () !! val firstMovie : TmdbMovie . Slim ? = castMovie . firstOrNull () val castTv : List < TmdbShow . Slim > = TMDb . personService . tvCast ( SOME_ID ). invoke () !! val firstShow : TmdbShow . Slim ? = castTv . firstOrNull () // ... If you want to fetch crew and cast movies you have to do it separately and in case you\u2019re caching the responses there won\u2019t be additional traffic since the API url is the same. Account \u00b6 Get Request Token and Access Token \u00b6 TMDb . init ( YOUR_API_KEY , V4_AUTH_KEY ) // Get request token val requestTokenResponse : TmdbMessage . RequestToken = TMDb . authService . requestToken (). invoke () !! if ( requestTokenResponse . success ) { // Authenticate requestToken by redirecting the user to the // auth url on The Movie Database val authUrl = TMDb . authLink ( requestTokenResponse . requestToken ) // If request code is accepted get the access token val accessTokenResponse : TmdbMessage . AccessToken = TMDb . accessToken ( requestTokenResponse . requestToken ). invoke () !! if ( accessTokenResponse . success ) { // Save the access token to the TMDb object TMDb . accessToken = accessTokenResponse . accessToken } } Get account info and related data \u00b6 // Generate a session id using access token val sessionId = TMDb . accountService . accessTokenToSessionID ( ACCESS_TOKEN ). invoke () !! . sessionId // Save the session id to the TMDb object TMDb . sessionId = sessionId val account : TmdbAccount = TMDb . accountService . details (). invoke () !! val favoriteShowsPage : TmdbPage < TmdbShow . Slim > = TMDb . favoriteTv ( account . accountId ). invoke () !! Lists \u00b6","title":"Recipes"},{"location":"recipes/#recipes","text":"In this section I\u2019ll show you some examples and customizations which can be done with this library.","title":"Recipes"},{"location":"recipes/#customization","text":"","title":"Customization"},{"location":"recipes/#caching","text":"Since the API data isn\u2019t updating that often it isn\u2019t necessary to fetch the same resource over and over. You can set the cache time interval and the condition for being connected to the network: // Setting condition or passing null to disable caching (default: null) TMDb . onlineCondition { return InternetUtility . isConnectedToNetwork () } // Duration to use cached data if connected to network (default: 2 hours) TMDb . onlineCache ( /* duration */ 2 , /* unit */ TimeUnit . HOURS ) // Duration to use cached data if disconnected from network (default: 2 days) TMDb . offlineCache ( /* duration */ 1 , /* unit */ TimeUnit . DAYS )","title":"Caching"},{"location":"recipes/#modify-requests-before-calling","text":"By default, requests support caching, but you can add your own modifications by using TMDbInterceptor if you\u2019d like: val customInterceptor = TMDbInterceptor ( \"YOUR_KEY\" , \"\" ) { requestBuilder -> requestBuilder . addHeader ( \"headerName\" , \"value\" ) // or a custom offline handling } TMDb . tmdbInterceptor = customInterceptor TMDb . init ( \"YOUR_KEY\" )","title":"Modify requests before calling"},{"location":"recipes/#general","text":"","title":"General"},{"location":"recipes/#appendtoresponse","text":"With AppendToReponse you can add optional data to the details call such as images and credits. If it isn\u2019t passed accessing the field returns an empty list (or of the API doesn\u2019t have the data). val appendToResponse = AppendToResponse ( AppendToResponse . Item . VIDEOS ) val tvShow : TmdbShow = TMDb . showService . details ( SOME_ID , append = appendToResponse ). invoke () !! val youtubeVideoThumbnail : String ? = if ( tvShow . videos . isEmpty ()) null else tvShow . videos [ 0 ]. youtubeThumbnail ()","title":"AppendToResponse"},{"location":"recipes/#get-targeted-data-directly","text":"If you\u2019re interested in specific data only (for example movies/shows in which a person was cast member of), you can retrieve this data directly with a call: val castMovies : List < TmdbMovie . Slim > = TMDb . personService . movieCast ( SOME_ID ). invoke () !! val firstMovie : TmdbMovie . Slim ? = castMovie . firstOrNull () val castTv : List < TmdbShow . Slim > = TMDb . personService . tvCast ( SOME_ID ). invoke () !! val firstShow : TmdbShow . Slim ? = castTv . firstOrNull () // ... If you want to fetch crew and cast movies you have to do it separately and in case you\u2019re caching the responses there won\u2019t be additional traffic since the API url is the same.","title":"Get targeted data directly"},{"location":"recipes/#account","text":"","title":"Account"},{"location":"recipes/#get-request-token-and-access-token","text":"TMDb . init ( YOUR_API_KEY , V4_AUTH_KEY ) // Get request token val requestTokenResponse : TmdbMessage . RequestToken = TMDb . authService . requestToken (). invoke () !! if ( requestTokenResponse . success ) { // Authenticate requestToken by redirecting the user to the // auth url on The Movie Database val authUrl = TMDb . authLink ( requestTokenResponse . requestToken ) // If request code is accepted get the access token val accessTokenResponse : TmdbMessage . AccessToken = TMDb . accessToken ( requestTokenResponse . requestToken ). invoke () !! if ( accessTokenResponse . success ) { // Save the access token to the TMDb object TMDb . accessToken = accessTokenResponse . accessToken } }","title":"Get Request Token and Access Token"},{"location":"recipes/#get-account-info-and-related-data","text":"// Generate a session id using access token val sessionId = TMDb . accountService . accessTokenToSessionID ( ACCESS_TOKEN ). invoke () !! . sessionId // Save the session id to the TMDb object TMDb . sessionId = sessionId val account : TmdbAccount = TMDb . accountService . details (). invoke () !! val favoriteShowsPage : TmdbPage < TmdbShow . Slim > = TMDb . favoriteTv ( account . accountId ). invoke () !!","title":"Get account info and related data"},{"location":"recipes/#lists","text":"","title":"Lists"}]}