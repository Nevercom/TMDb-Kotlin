{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TMDb-Kotlin \u00b6 Hello folks, this is the documentation page for the TMDb wrapper TMDb-Kotlin is written in and for Kotlin. I\u2019ve created the library for Android apps primarily but it can be also used in any Gradle project. Most of the functionality and callbacks are implemented (but not all). The library is therefore WIP, so there might be breaking changes in the future (but I hope not). If you\u2019ve got questions, suggestions or encounter any issues feel free to contact me via GitHub (link to the upper right). I\u2019d be happy to help ;) Setup \u00b6 Import into your project \u00b6 This library uses the JitPack.io so you\u2019ve to dd it to your projects gradle file: repositories { maven { url \"https://jitpack.io\" } } Then, on app level add the library: dependencies { implementation \"com.github.vkay94:TMDb-Kotlin:xyz\" // This module uses the ThreetenABP library to ensure LocalDate support in // Android versions below API 26 so you should use this as well for // using dates. implementation \"com.jakewharton.threetenabp:threetenabp:1.3.0\" } Initialize the instance \u00b6 Basic initialization: TMDb . init ( API_KEY [, V4_AUTH_KEY ]) // [] = optional In Android applications it is best-practice to initialize the instance directly within App to make use of Kotlin\u2019s objects, so the instance can be used in the whole app directly. App.kt class App : Application () { override fun onCreate () { TMDb . init ( API_KEY ) // or TMDb.init(YOUR_API_KEY, V4_AUTH_KEY) for authentication } } AndroidManifest.xml <manifest ... > <uses-permission android:name= \"android.permission.INTERNET\" /> <application android:name= \".App\" ... > </application> </manifest> Making requests \u00b6 In the moment all calls are suspended and require to be called in Kotlin Coroutines. An overview of how to use them can be found here: Composing suspending functions . They\u2019re also wrapped in NetworkResponse s so you can react for errors easily or access the data directly. Examples \u00b6 Searching with error handling \u00b6 There are four cases which the response can take value of: Success , ServerError , NetworkError and UnknownError . You should take a look here for more info. fun main () = runBlocking { TMDb . init ( \"YOUR_API_KEY\" ) when ( val response = TMDb . searchService . tv ( \"Black Clover\" )) { // Type: NetworkResponse<TmdbPage<TmdbShow.Slim>, TmdbError.DefaultError> is NetworkResponse . Success -> { val searchPage : TmdbPage < TmdbShow . Slim > = response . body if ( searchPage . totalResults > 0 ) { println ( \"First result's title: ${searchPage.results[0].title}\" ) } } is NetworkResponse . ServerError -> { val errorBody : TmdbErrorResponse ? = response . body println ( \"ServerError: Message = ${errorBody?.message}\" ) } is NetworkResponse . NetworkError -> { val error : IOException = response . error println ( \"NetworkError: Message = ${error.message}\" ) } is NetworkResponse . UnknownError -> { val error : Throwable = response . error println ( \"UnknownError: Message = ${error.message}\" ) } } } Searching with direct access \u00b6 You can also access the response directly without checking for the NetworkResponse type by calling invoke() . In this case the object might by null : fun main () = runBlocking { TMDb . init ( \"YOUR_API_KEY\" ) val searchPage : TmdbPage < TmdbShow . Slim >? = TMDb . searchService . tv ( \"Black Clover\" ). invoke () searchPage ?. let { if ( searchPage . totalResults > 0 ) { println ( \"First result: ${searchPage.results[0].title}\" ) } } } Next steps \u00b6 This introduction is pretty briefly. For some more practice scenarios you can either look into the Recipes page on the left or the tests folder on Github here . Thanks \u00b6 Thanks go to TMDb-Java by xyz for the basic idea, especially the service accessing in the object instance NetworkResponse library by xyz for the great error handling Moshi by Square for custom JSON deserializing to make the useage more natural","title":"Quick start"},{"location":"#tmdb-kotlin","text":"Hello folks, this is the documentation page for the TMDb wrapper TMDb-Kotlin is written in and for Kotlin. I\u2019ve created the library for Android apps primarily but it can be also used in any Gradle project. Most of the functionality and callbacks are implemented (but not all). The library is therefore WIP, so there might be breaking changes in the future (but I hope not). If you\u2019ve got questions, suggestions or encounter any issues feel free to contact me via GitHub (link to the upper right). I\u2019d be happy to help ;)","title":"TMDb-Kotlin"},{"location":"#setup","text":"","title":"Setup"},{"location":"#import-into-your-project","text":"This library uses the JitPack.io so you\u2019ve to dd it to your projects gradle file: repositories { maven { url \"https://jitpack.io\" } } Then, on app level add the library: dependencies { implementation \"com.github.vkay94:TMDb-Kotlin:xyz\" // This module uses the ThreetenABP library to ensure LocalDate support in // Android versions below API 26 so you should use this as well for // using dates. implementation \"com.jakewharton.threetenabp:threetenabp:1.3.0\" }","title":"Import into your project"},{"location":"#initialize-the-instance","text":"Basic initialization: TMDb . init ( API_KEY [, V4_AUTH_KEY ]) // [] = optional In Android applications it is best-practice to initialize the instance directly within App to make use of Kotlin\u2019s objects, so the instance can be used in the whole app directly. App.kt class App : Application () { override fun onCreate () { TMDb . init ( API_KEY ) // or TMDb.init(YOUR_API_KEY, V4_AUTH_KEY) for authentication } } AndroidManifest.xml <manifest ... > <uses-permission android:name= \"android.permission.INTERNET\" /> <application android:name= \".App\" ... > </application> </manifest>","title":"Initialize the instance"},{"location":"#making-requests","text":"In the moment all calls are suspended and require to be called in Kotlin Coroutines. An overview of how to use them can be found here: Composing suspending functions . They\u2019re also wrapped in NetworkResponse s so you can react for errors easily or access the data directly.","title":"Making requests"},{"location":"#examples","text":"","title":"Examples"},{"location":"#searching-with-error-handling","text":"There are four cases which the response can take value of: Success , ServerError , NetworkError and UnknownError . You should take a look here for more info. fun main () = runBlocking { TMDb . init ( \"YOUR_API_KEY\" ) when ( val response = TMDb . searchService . tv ( \"Black Clover\" )) { // Type: NetworkResponse<TmdbPage<TmdbShow.Slim>, TmdbError.DefaultError> is NetworkResponse . Success -> { val searchPage : TmdbPage < TmdbShow . Slim > = response . body if ( searchPage . totalResults > 0 ) { println ( \"First result's title: ${searchPage.results[0].title}\" ) } } is NetworkResponse . ServerError -> { val errorBody : TmdbErrorResponse ? = response . body println ( \"ServerError: Message = ${errorBody?.message}\" ) } is NetworkResponse . NetworkError -> { val error : IOException = response . error println ( \"NetworkError: Message = ${error.message}\" ) } is NetworkResponse . UnknownError -> { val error : Throwable = response . error println ( \"UnknownError: Message = ${error.message}\" ) } } }","title":"Searching with error handling"},{"location":"#searching-with-direct-access","text":"You can also access the response directly without checking for the NetworkResponse type by calling invoke() . In this case the object might by null : fun main () = runBlocking { TMDb . init ( \"YOUR_API_KEY\" ) val searchPage : TmdbPage < TmdbShow . Slim >? = TMDb . searchService . tv ( \"Black Clover\" ). invoke () searchPage ?. let { if ( searchPage . totalResults > 0 ) { println ( \"First result: ${searchPage.results[0].title}\" ) } } }","title":"Searching with direct access"},{"location":"#next-steps","text":"This introduction is pretty briefly. For some more practice scenarios you can either look into the Recipes page on the left or the tests folder on Github here .","title":"Next steps"},{"location":"#thanks","text":"Thanks go to TMDb-Java by xyz for the basic idea, especially the service accessing in the object instance NetworkResponse library by xyz for the great error handling Moshi by Square for custom JSON deserializing to make the useage more natural","title":"Thanks"},{"location":"future-plans/","text":"","title":"Future plans"},{"location":"recipes/","text":"","title":"Recipes"},{"location":"services/","text":"","title":"Services"},{"location":"gradle/gradle-index/","text":"Gradle \u00b6 Proguard \u00b6","title":"Gradle"},{"location":"gradle/gradle-index/#gradle","text":"","title":"Gradle"},{"location":"gradle/gradle-index/#proguard","text":"","title":"Proguard"},{"location":"structure/","text":"Overview \u00b6 Philosophy Direct access usefull addition methods for logic scenarios (TMDbImage get Beispiel) except of simple data Dates mittels threeben f\u00fcr mehr Android support","title":"Overview"},{"location":"structure/#overview","text":"Philosophy Direct access usefull addition methods for logic scenarios (TMDbImage get Beispiel) except of simple data Dates mittels threeben f\u00fcr mehr Android support","title":"Overview"},{"location":"structure/structure-core-classes/","text":"","title":"Structure core classes"}]}